// Generated by CoffeeScript 1.7.1

/*
  backbone-mongo.js 0.6.0
  Copyright (c) 2013-2014 Vidigami
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
  Source: https://github.com/vidigami/backbone-orm
  Dependencies: Backbone.js and Underscore.js.
 */

(function() {
  var Cursor, _;

  _ = require('backbone-orm')._;

  Cursor = null;

  module.exports = function(model_type, query, iterator, callback) {
    var cursor, model_limit, options, parsed_query, processed_count;
    if (!Cursor) {
      Cursor = require('../cursor');
    }
    options = query.$each || {};
    processed_count = 0;
    parsed_query = Cursor.parseQuery(_.omit(query, '$each'));
    _.defaults(parsed_query.cursor, {
      $offset: 0,
      $sort: 'id'
    });
    model_limit = parsed_query.cursor.$limit || Infinity;
    cursor = model_type.cursor(parsed_query);
    return cursor._queryToMongoCursor(function(err, mongo_cursor) {
      var aggregate_cursor, done, handleAggregateNext, handleNextItem, iteratorCallback, processMoreObjects, running_threads;
      if (err) {
        return callback(err);
      }
      aggregate_cursor = mongo_cursor.aggregate_cursor;
      if (!aggregate_cursor) {
        if (options.fetch) {
          mongo_cursor.batchSize(options.fetch);
        }
      }
      running_threads = 0;
      callback = _.once(callback);
      done = false;
      iteratorCallback = function(err) {
        if (callback.ran) {
          return;
        }
        if (err) {
          return (callback(err), callback.ran = true);
        }
        processed_count++;
        running_threads--;
        if (done || processed_count >= model_limit) {
          if (running_threads <= 0) {
            callback(null, processed_count);
            callback.ran = true;
          }
        } else {
          return processMoreObjects();
        }
      };
      processMoreObjects = function() {
        if (running_threads >= options.threads) {
          return;
        }
        running_threads++;
        if (aggregate_cursor) {
          return aggregate_cursor.next(handleAggregateNext);
        } else {
          return mongo_cursor.nextObject(handleNextItem);
        }
      };
      handleAggregateNext = function(err, result) {
        if (err) {
          return iteratorCallback(err);
        }
        result.id = result.__id.toString();
        delete result._id;
        delete result.__id;
        return handleNextItem(err, result);
      };
      handleNextItem = function(err, item) {
        var call_iterator;
        if (err) {
          return iteratorCallback(new Error("Failed to get models. Error: " + err));
        }
        if (!item) {
          done = true;
          return iteratorCallback();
        }
        if (options.json) {
          call_iterator = iterator;
        } else {
          call_iterator = function(json, callback) {
            return cursor._createModelsForJSON(json, function(err, model) {
              if (err) {
                return callback(err);
              }
              return iterator(model, callback);
            });
          };
        }
        call_iterator(item, iteratorCallback);
        return processMoreObjects();
      };
      return processMoreObjects();
    });
  };

}).call(this);
